<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>Vuex源码解析</title> <meta name="description" content="Vuex源码解析"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="/jekyll/update/2017/11/19/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"> <link rel="alternate" type="application/rss+xml" title="" href="/feed.xml"> <script src="/assets/js/modernizr.js"></script> </head> <body"> <main class="wrapper"> <header class="site-header"> <a href="#navbar" id="menu-burger" class="menu-burger">Menu <span class="nav-icon"></span> <svg x="0px" y="0px" width="54px" height="54px" viewBox="0 0 54 54"> <circle fill="transparent" stroke="#000000" stroke-width="1" cx="27" cy="27" r="25" stroke-dasharray="157 157" stroke-dashoffset="157"></circle> </svg> </a> <div id="navbar" class="navbar"> <div class="navigation-wrapper"> <div class="half-block"> <h2>Navigation</h2> <nav> <ul class="primary-nav"> <li><a href="/">Home</a></li> <li><a href="/blog">Blog</a></li> <li><a href="/about">About</a></li> <li><a href="https://github.com/answershuto" ><i class="icon icon-github"></i> Github</a></li> </ul> </nav> </div> </div> </div> </header> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header intro"> <div class="intro-in"> <h1 class="post-title" itemprop="name headline">Vuex源码解析</h1> <p class="post-meta"><time datetime="2017-11-19T21:10:00+08:00" itemprop="datePublished">Nov 19, 2017</time></p> </div> </header> <div class="post-content container" itemprop="articleBody"> <h2 id="vuex">Vuex</h2> <p>我们在使用Vue.js开发复杂的应用时，经常会遇到多个组件共享同一个状态，亦或是多个组件会去更新同一个状态，在应用代码量较少的时候，我们可以组件间通信去维护修改数据，或者是通过事件总线来进行数据的传递以及修改。但是当应用逐渐庞大以后，代码就会变得难以维护，从父组件开始通过prop传递多层嵌套的数据由于层级过深而显得异常脆弱，而事件总线也会因为组件的增多、代码量的增大而显得交互错综复杂，难以捋清其中的传递关系。</p> <p>那么为什么我们不能将数据层与组件层抽离开来呢？把数据层放到全局形成一个单一的Store，组件层变得更薄，专门用来进行数据的展示及操作。所有数据的变更都需要经过全局的Store来进行，形成一个单向数据流，使数据变化变得“可预测”。</p> <p>Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架（优点是更加简洁高效，缺点是只能跟Vue.js搭配使用）。具体使用方法及API可以参考<a href="https://vuex.vuejs.org/zh-cn/intro.html">Vuex的官网</a>。</p> <p>先来看一下这张Vuex的数据流程图，熟悉Vuex使用的同学应该已经有所了解。</p> <p><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt="" /></p> <p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，所有修改State的操作必须通过Mutation进行，Mutation的同时提供了订阅者模式供外部插件调用获取State数据的更新。所有异步接口需要走Action，常见于调用后端接口异步获取更新数据，而Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。Vuex运行依赖Vue内部数据双向绑定机制，需要new一个Vue对象来实现“响应式化”，所以Vuex是一个专门为Vue.js设计的状态管理库。</p> <h2 id="section">安装</h2> <p>使用过Vuex的朋友一定知道，Vuex的安装十分简单，只需要提供一个store，然后执行下面两句代码即完成的Vuex的引入。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nx">Vue</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">Vuex</span><span class="p">);</span>

<span class="cm">/*将store放入Vue创建时的option中*/</span>
<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="na">el</span><span class="p">:</span> <span class="s1">'#app'</span><span class="p">,</span>
    <span class="nx">store</span>
<span class="p">});</span>
</code></pre></div> <p>那么问题来了，Vuex是怎样把store注入到Vue实例中去的呢？</p> <p>Vue.js提供了<a href="https://cn.vuejs.org/v2/api/#Vue-use">Vue.use</a>方法用来给Vue.js安装插件，内部通过调用插件的install方法(当插件是一个对象的时候)来进行插件的安装。</p> <p>我们来看一下Vuex的install实现。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*暴露给外部的插件install方法，供Vue.use调用安装插件*/</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">install</span> <span class="p">(</span><span class="nx">_Vue</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">Vue</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*避免重复安装（Vue.use内部也会检测一次是否重复安装同一个插件）*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span>
        <span class="s1">'[vuex] already installed. Vue.use(Vuex) should be called only once.'</span>
      <span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="cm">/*保存Vue，同时用于检测是否重复安装*/</span>
  <span class="nx">Vue</span> <span class="o">=</span> <span class="nx">_Vue</span>
  <span class="cm">/*将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0)*/</span>
  <span class="nx">applyMixin</span><span class="p">(</span><span class="nx">Vue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>这段install代码做了两件事情，一件是防止Vuex被重复安装，另一件是执行applyMixin，目的是执行vuexInit方法初始化Vuex。Vuex针对Vue1.0与2.0分别进行了不同的处理，如果是Vue1.0，Vuex会将vuexInit方法放入Vue的_init方法中，而对于Vue2.0，则会将vuexinit混淆进Vue的beforeCreacte钩子中。来看一下vuexInit的代码。</p> <div class="highlighter-rouge"><pre class="highlight"><code> <span class="cm">/*Vuex的init钩子，会存入每一个Vue实例等钩子列表*/</span>
  <span class="kd">function</span> <span class="nx">vuexInit</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$options</span>
    <span class="c1">// store injection</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">store</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/*存在store其实代表的就是Root节点，直接执行store（function时）或者使用store（非function）*/</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$store</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">options</span><span class="p">.</span><span class="nx">store</span> <span class="o">===</span> <span class="s1">'function'</span>
        <span class="p">?</span> <span class="nx">options</span><span class="p">.</span><span class="nx">store</span><span class="p">()</span>
        <span class="p">:</span> <span class="nx">options</span><span class="p">.</span><span class="nx">store</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">parent</span> <span class="o">&amp;&amp;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">$store</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/*子组件直接从父组件中获取$store，这样就保证了所有组件都公用了全局的同一份store*/</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$store</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">$store</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div> <p>vuexInit会尝试从options中获取store，如果当前组件是根组件（Root节点），则options中会存在store，直接获取赋值给$store即可。如果当前组件非根组件，则通过options中的parent获取父组件的$store引用。这样一来，所有的组件都获取到了同一份内存地址的Store实例，于是我们可以在每一个组件中通过this.$store愉快地访问全局的Store实例了。</p> <p>那么，什么是Store实例？</p> <h2 id="store">Store</h2> <p>我们传入到根组件到store，就是Store实例，用Vuex提供到Store方法构造。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">export</span> <span class="k">default</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
    <span class="na">strict</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">modules</span><span class="p">:</span> <span class="p">{</span>
        <span class="nx">moduleA</span><span class="p">,</span>
        <span class="nx">moduleB</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div> <p>我们来看一下Store的实现。首先是构造函数。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nx">constructor</span> <span class="p">(</span><span class="nx">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// Auto install if it is not done yet and `window` has `Vue`.</span>
    <span class="c1">// To allow users to avoid auto-installation in some cases,</span>
    <span class="c1">// this code should be placed here. See #731</span>
    <span class="cm">/*
      在浏览器环境下，如果插件还未安装（!Vue即判断是否未安装），则它会自动安装。
      它允许用户在某些情况下避免自动安装。
    */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">Vue</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nb">window</span> <span class="o">!==</span> <span class="s1">'undefined'</span> <span class="o">&amp;&amp;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">Vue</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">install</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">Vue</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">assert</span><span class="p">(</span><span class="nx">Vue</span><span class="p">,</span> <span class="err">`</span><span class="nx">must</span> <span class="nx">call</span> <span class="nx">Vue</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">Vuex</span><span class="p">)</span> <span class="nx">before</span> <span class="nx">creating</span> <span class="nx">a</span> <span class="nx">store</span> <span class="nx">instance</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
      <span class="nx">assert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">Promise</span> <span class="o">!==</span> <span class="s1">'undefined'</span><span class="p">,</span> <span class="err">`</span><span class="nx">vuex</span> <span class="nx">requires</span> <span class="nx">a</span> <span class="nx">Promise</span> <span class="nx">polyfill</span> <span class="k">in</span> <span class="k">this</span> <span class="nx">browser</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
      <span class="nx">assert</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Store</span><span class="p">,</span> <span class="err">`</span><span class="nx">Store</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">called</span> <span class="kd">with</span> <span class="nx">the</span> <span class="k">new</span> <span class="nx">operator</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kr">const</span> <span class="p">{</span>
      <span class="cm">/*一个数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，可以监听 mutation（用于外部地数据持久化、记录或调试）或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者）*/</span>
      <span class="nx">plugins</span> <span class="o">=</span> <span class="p">[],</span>
      <span class="cm">/*使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。*/</span>
      <span class="nx">strict</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span> <span class="o">=</span> <span class="nx">options</span>

    <span class="cm">/*从option中取出state，如果state是function则执行，最终得到一个对象*/</span>
    <span class="kd">let</span> <span class="p">{</span>
      <span class="nx">state</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">}</span> <span class="o">=</span> <span class="nx">options</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">state</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// store internal state</span>
    <span class="cm">/* 用来判断严格模式下是否是用mutation修改state的 */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_committing</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="cm">/* 存放action */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_actions</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
    <span class="cm">/* 存放mutation */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_mutations</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
    <span class="cm">/* 存放getter */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_wrappedGetters</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
    <span class="cm">/* module收集器 */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_modules</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ModuleCollection</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span>
    <span class="cm">/* 根据namespace存放module */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_modulesNamespaceMap</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
    <span class="cm">/* 存放订阅者 */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_subscribers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="cm">/* 用以实现Watch的Vue实例 */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_watcherVM</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">()</span>

    <span class="c1">// bind commit and dispatch to self</span>
    <span class="cm">/*将dispatch与commit调用的this绑定为store对象本身，否则在组件内部this.dispatch时的this会指向组件的vm*/</span>
    <span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">this</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">dispatch</span><span class="p">,</span> <span class="nx">commit</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span>
    <span class="cm">/* 为dispatch与commit绑定this（Store实例本身） */</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dispatch</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">boundDispatch</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">dispatch</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">commit</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">boundCommit</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">commit</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// strict mode</span>
    <span class="cm">/*严格模式(使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误)*/</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">strict</span> <span class="o">=</span> <span class="nx">strict</span>

    <span class="c1">// init root module.</span>
    <span class="c1">// this also recursively registers all sub-modules</span>
    <span class="c1">// and collects all module getters inside this._wrappedGetters</span>
    <span class="cm">/*初始化根module，这也同时递归注册了所有子modle，收集所有module的getter到_wrappedGetters中去，this._modules.root代表根module才独有保存的Module对象*/</span>
    <span class="nx">installModule</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="p">[],</span> <span class="k">this</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>

    <span class="c1">// initialize the store vm, which is responsible for the reactivity</span>
    <span class="c1">// (also registers _wrappedGetters as computed properties)</span>
    <span class="cm">/* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */</span>
    <span class="nx">resetStoreVM</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span>

    <span class="c1">// apply plugins</span>
    <span class="cm">/* 调用插件 */</span>
    <span class="nx">plugins</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">plugin</span> <span class="o">=&gt;</span> <span class="nx">plugin</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>

    <span class="cm">/* devtool插件 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">Vue</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">devtools</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">devtoolPlugin</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div> <p>Store的构造类除了初始化一些内部变量以外，主要执行了installModule（初始化module）以及resetStoreVM（通过VM使store“响应式”）。</p> <h3 id="installmodule">installModule</h3> <p>installModule的作用主要是用为module加上namespace名字空间（如果有）后，注册mutation、action以及getter，同时递归安装所有子module。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*初始化module*/</span>
<span class="kd">function</span> <span class="nx">installModule</span> <span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">rootState</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">module</span><span class="p">,</span> <span class="nx">hot</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 是否是根module */</span>
  <span class="kr">const</span> <span class="nx">isRoot</span> <span class="o">=</span> <span class="o">!</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span>
  <span class="cm">/* 获取module的namespace */</span>
  <span class="kr">const</span> <span class="nx">namespace</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">getNamespace</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>

  <span class="c1">// register in namespace map</span>
  <span class="cm">/* 如果有namespace则在_modulesNamespaceMap中注册 */</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">namespaced</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">store</span><span class="p">.</span><span class="nx">_modulesNamespaceMap</span><span class="p">[</span><span class="nx">namespace</span><span class="p">]</span> <span class="o">=</span> <span class="nx">module</span>
  <span class="p">}</span>

  <span class="c1">// set state</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isRoot</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">hot</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 获取父级的state */</span>
    <span class="kr">const</span> <span class="nx">parentState</span> <span class="o">=</span> <span class="nx">getNestedState</span><span class="p">(</span><span class="nx">rootState</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="cm">/* module的name */</span>
    <span class="kr">const</span> <span class="nx">moduleName</span> <span class="o">=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="nx">store</span><span class="p">.</span><span class="err">`</span><span class="nx">_withCommit</span><span class="err">`</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="cm">/* 将子module设置称响应式的 */</span>
      <span class="nx">Vue</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">parentState</span><span class="p">,</span> <span class="nx">moduleName</span><span class="p">,</span> <span class="nx">module</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="kr">const</span> <span class="nx">local</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nx">makeLocalContext</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">namespace</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>

  <span class="cm">/* 遍历注册mutation */</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">forEachMutation</span><span class="p">((</span><span class="nx">mutation</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">namespacedType</span> <span class="o">=</span> <span class="nx">namespace</span> <span class="o">+</span> <span class="nx">key</span>
    <span class="nx">registerMutation</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">namespacedType</span><span class="p">,</span> <span class="nx">mutation</span><span class="p">,</span> <span class="nx">local</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="cm">/* 遍历注册action */</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">forEachAction</span><span class="p">((</span><span class="nx">action</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">namespacedType</span> <span class="o">=</span> <span class="nx">namespace</span> <span class="o">+</span> <span class="nx">key</span>
    <span class="nx">registerAction</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">namespacedType</span><span class="p">,</span> <span class="nx">action</span><span class="p">,</span> <span class="nx">local</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="cm">/* 遍历注册getter */</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">forEachGetter</span><span class="p">((</span><span class="nx">getter</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">namespacedType</span> <span class="o">=</span> <span class="nx">namespace</span> <span class="o">+</span> <span class="nx">key</span>
    <span class="nx">registerGetter</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">namespacedType</span><span class="p">,</span> <span class="nx">getter</span><span class="p">,</span> <span class="nx">local</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="cm">/* 递归安装mudule */</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">forEachChild</span><span class="p">((</span><span class="nx">child</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">installModule</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">rootState</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">hot</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div> <h3 id="resetstorevm">resetStoreVM</h3> <p>在说resetStoreVM之前，先来看一个小demo。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">globalData</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">d</span><span class="p">:</span> <span class="s1">'hello world'</span>
<span class="p">};</span>
<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="nx">data</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">$</span><span class="na">$state</span><span class="p">:</span> <span class="p">{</span>
                <span class="nx">globalData</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="cm">/* modify */</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">globalData</span><span class="p">.</span><span class="nx">d</span> <span class="o">=</span> <span class="s1">'hi~'</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

<span class="nx">Vue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">globalData</span> <span class="o">=</span> <span class="nx">globalData</span><span class="p">;</span>

<span class="cm">/* 任意模板中 */</span>
<span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div> <p>上述代码在全局有一个globalData，它被传入一个Vue对象的data中，之后在任意Vue模板中对该变量进行展示，因为此时globalData已经在Vue的prototype上了所以直接通过this.prototype访问，也就是在模板中的。此时，setTimeout在1s之后将globalData.d进行修改，我们发现模板中的globalData.d发生了变化。其实上述部分就是Vuex依赖Vue核心实现数据的“响应式化”。</p> <p>不熟悉Vue.js响应式原理的同学可以通过笔者另一篇文章<a href="https://github.com/answershuto/learnVue/blob/master/docs/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown">响应式原理</a>了解Vue.js是如何进行数据双向绑定的。</p> <p>接着来看代码。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */</span>
<span class="kd">function</span> <span class="nx">resetStoreVM</span> <span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">hot</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 存放之前的vm对象 */</span>
  <span class="kr">const</span> <span class="nx">oldVm</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span> 

  <span class="c1">// bind store public getters</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">getters</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kr">const</span> <span class="nx">wrappedGetters</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_wrappedGetters</span>
  <span class="kr">const</span> <span class="nx">computed</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="cm">/* 通过Object.defineProperty为每一个getter方法设置get方法，比如获取this.$store.getters.test的时候获取的是store._vm.test，也就是Vue对象的computed属性 */</span>
  <span class="nx">forEachValue</span><span class="p">(</span><span class="nx">wrappedGetters</span><span class="p">,</span> <span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// use computed to leverage its lazy-caching mechanism</span>
    <span class="nx">computed</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">store</span><span class="p">)</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getters</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">get</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span>
      <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span> <span class="c1">// for local getters</span>
    <span class="p">})</span>
  <span class="p">})</span>

  <span class="c1">// use a Vue instance to store the state tree</span>
  <span class="c1">// suppress warnings just in case the user has added</span>
  <span class="c1">// some funky global mixins</span>
  <span class="kr">const</span> <span class="nx">silent</span> <span class="o">=</span> <span class="nx">Vue</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">silent</span>
  <span class="cm">/* Vue.config.silent暂时设置为true的目的是在new一个Vue实例的过程中不会报出一切警告 */</span>
  <span class="nx">Vue</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">silent</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="cm">/*  这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">$</span><span class="na">$state</span><span class="p">:</span> <span class="nx">state</span>
    <span class="p">},</span>
    <span class="nx">computed</span>
  <span class="p">})</span>
  <span class="nx">Vue</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">silent</span> <span class="o">=</span> <span class="nx">silent</span>

  <span class="c1">// enable strict mode for new vm</span>
  <span class="cm">/* 使能严格模式，保证修改store只能通过mutation */</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">strict</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">enableStrictMode</span><span class="p">(</span><span class="nx">store</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">oldVm</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 解除旧vm的state的引用，以及销毁旧的Vue对象 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">hot</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// dispatch changes in all subscribed watchers</span>
      <span class="c1">// to force getter re-evaluation for hot reloading.</span>
      <span class="nx">store</span><span class="p">.</span><span class="nx">_withCommit</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">oldVm</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">$$state</span> <span class="o">=</span> <span class="kc">null</span>
      <span class="p">})</span>
    <span class="p">}</span>
    <span class="nx">Vue</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">oldVm</span><span class="p">.</span><span class="nx">$destroy</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>resetStoreVM首先会遍历wrappedGetters，使用Object.defineProperty方法为每一个getter绑定上get方法，这样我们就可以在组件里访问this.$store.getter.test就等同于访问store._vm.test。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nx">forEachValue</span><span class="p">(</span><span class="nx">wrappedGetters</span><span class="p">,</span> <span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// use computed to leverage its lazy-caching mechanism</span>
  <span class="nx">computed</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">store</span><span class="p">)</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">getters</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">get</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span><span class="p">[</span><span class="nx">key</span><span class="p">],</span>
    <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span> <span class="c1">// for local getters</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div> <p>之后Vuex采用了new一个Vue对象来实现数据的“响应式化”，运用Vue.js内部提供的数据双向绑定功能来实现store的数据与视图的同步更新。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">$</span><span class="na">$state</span><span class="p">:</span> <span class="nx">state</span>
  <span class="p">},</span>
  <span class="nx">computed</span>
<span class="p">})</span>
</code></pre></div> <p>这时候我们访问store._vm.test也就访问了Vue实例中的属性。</p> <p>这两步执行完以后，我们就可以通过this.$store.getter.test访问vm中的test属性了。</p> <h3 id="section-1">严格模式</h3> <p>Vuex的Store构造类的option有一个strict的参数，可以控制Vuex执行严格模式，严格模式下，所有修改state的操作必须通过mutation实现，否则会抛出错误。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 使能严格模式 */</span>
<span class="kd">function</span> <span class="nx">enableStrictMode</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_vm</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">$$state</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */</span>
      <span class="nx">assert</span><span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">_committing</span><span class="p">,</span> <span class="err">`</span><span class="nx">Do</span> <span class="nx">not</span> <span class="nx">mutate</span> <span class="nx">vuex</span> <span class="nx">store</span> <span class="nx">state</span> <span class="nx">outside</span> <span class="nx">mutation</span> <span class="nx">handlers</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="p">{</span> <span class="na">deep</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">sync</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div> <p>首先，在严格模式下，Vuex会利用vm的$watch方法来观察$$state，也就是Store的state，在它被修改的时候进入回调。我们发现，回调中只有一句话，用assert断言来检测store._committing，当store._committing为false的时候会触发断言，抛出异常。</p> <p>我们发现，Store的commit方法中，执行mutation的语句是这样的。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">_withCommit</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">entry</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="nx">commitIterator</span> <span class="p">(</span><span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handler</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div> <p>再来看看_withCommit的实现。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="nx">_withCommit</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 调用withCommit修改state的值时会将store的committing值置为true，内部会有断言检查该值，在严格模式下只允许使用mutation来修改store中的值，而不允许直接修改store的数值 */</span>
  <span class="kr">const</span> <span class="nx">committing</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_committing</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_committing</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="nx">fn</span><span class="p">()</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_committing</span> <span class="o">=</span> <span class="nx">committing</span>
<span class="p">}</span>
</code></pre></div> <p>我们发现，通过commit（mutation）修改state数据的时候，会再调用mutation方法之前将committing置为true，接下来再通过mutation函数修改state中的数据，这时候触发$watch中的回调断言committing是不会抛出异常的（此时committing为true）。而当我们直接修改state的数据时，触发$watch的回调执行断言，这时committing为false，则会抛出异常。这就是Vuex的严格模式的实现。</p> <p>接下来我们来看看Store提供的一些API。</p> <h3 id="commitmutationhttpsvuexvuejsorgzh-cnmutationshtml">commit（<a href="https://vuex.vuejs.org/zh-cn/mutations.html">mutation</a>）</h3> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 调用mutation的commit方法 */</span>
<span class="nx">commit</span> <span class="p">(</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">_payload</span><span class="p">,</span> <span class="nx">_options</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// check object-style commit</span>
  <span class="cm">/* 校验参数 */</span>
  <span class="kr">const</span> <span class="p">{</span>
    <span class="nx">type</span><span class="p">,</span>
    <span class="nx">payload</span><span class="p">,</span>
    <span class="nx">options</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nx">unifyObjectStyle</span><span class="p">(</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">_payload</span><span class="p">,</span> <span class="nx">_options</span><span class="p">)</span>

  <span class="kr">const</span> <span class="nx">mutation</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">}</span>
  <span class="cm">/* 取出type对应的mutation的方法 */</span>
  <span class="kr">const</span> <span class="nx">entry</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_mutations</span><span class="p">[</span><span class="nx">type</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="err">`</span><span class="p">[</span><span class="nx">vuex</span><span class="p">]</span> <span class="nx">unknown</span> <span class="nx">mutation</span> <span class="nx">type</span><span class="err">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">type</span><span class="p">}</span><span class="err">`</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="cm">/* 执行mutation中的所有方法 */</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_withCommit</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">entry</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="nx">commitIterator</span> <span class="p">(</span><span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handler</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
  <span class="cm">/* 通知所有订阅者 */</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_subscribers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">sub</span> <span class="o">=&gt;</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">mutation</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">))</span>

  <span class="k">if</span> <span class="p">(</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span> <span class="o">&amp;&amp;</span>
    <span class="nx">options</span> <span class="o">&amp;&amp;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">silent</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span>
      <span class="err">`</span><span class="p">[</span><span class="nx">vuex</span><span class="p">]</span> <span class="nx">mutation</span> <span class="nx">type</span><span class="err">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">type</span><span class="p">}.</span> <span class="nx">Silent</span> <span class="nx">option</span> <span class="nx">has</span> <span class="nx">been</span> <span class="nx">removed</span><span class="p">.</span> <span class="err">`</span> <span class="o">+</span>
      <span class="s1">'Use the filter functionality in the vue-devtools'</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>commit方法会根据type找到并调用_mutations中的所有type对应的mutation方法，所以当没有namespace的时候，commit方法会触发所有module中的mutation方法。再执行完所有的mutation之后会执行_subscribers中的所有订阅者。我们来看一下_subscribers是什么。</p> <p>Store给外部提供了一个subscribe方法，用以注册一个订阅函数，会push到Store实例的_subscribers中，同时返回一个从_subscribers中注销该订阅者的方法。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 注册一个订阅函数，返回取消订阅的函数 */</span>
<span class="nx">subscribe</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">subs</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_subscribers</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">subs</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">subs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">subs</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">subs</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> <p>在commit结束以后则会调用这些_subscribers中的订阅者，这个订阅者模式提供给外部一个监视state变化的可能。state通过mutation改变时，可以有效补获这些变化。</p> <h3 id="dispatchactionhttpsvuexvuejsorgzh-cnactionshtml">dispatch（<a href="https://vuex.vuejs.org/zh-cn/actions.html">action</a>）</h3> <p>来看一下dispatch的实现。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 调用action的dispatch方法 */</span>
<span class="nx">dispatch</span> <span class="p">(</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">_payload</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// check object-style dispatch</span>
  <span class="kr">const</span> <span class="p">{</span>
    <span class="nx">type</span><span class="p">,</span>
    <span class="nx">payload</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nx">unifyObjectStyle</span><span class="p">(</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">_payload</span><span class="p">)</span>

  <span class="cm">/* actions中取出type对应的ation */</span>
  <span class="kr">const</span> <span class="nx">entry</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_actions</span><span class="p">[</span><span class="nx">type</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="err">`</span><span class="p">[</span><span class="nx">vuex</span><span class="p">]</span> <span class="nx">unknown</span> <span class="nx">action</span> <span class="nx">type</span><span class="err">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">type</span><span class="p">}</span><span class="err">`</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="cm">/* 是数组则包装Promise形成一个新的Promise，只有一个则直接返回第0个 */</span>
  <span class="k">return</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="p">?</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">entry</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">handler</span> <span class="o">=&gt;</span> <span class="nx">handler</span><span class="p">(</span><span class="nx">payload</span><span class="p">)))</span>
    <span class="p">:</span> <span class="nx">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="nx">payload</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>以及registerAction时候做的事情。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 遍历注册action */</span>
<span class="kd">function</span> <span class="nx">registerAction</span> <span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">,</span> <span class="nx">local</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 取出type对应的action */</span>
  <span class="kr">const</span> <span class="nx">entry</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_actions</span><span class="p">[</span><span class="nx">type</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">_actions</span><span class="p">[</span><span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[])</span>
  <span class="nx">entry</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kd">function</span> <span class="nx">wrappedActionHandler</span> <span class="p">(</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">dispatch</span><span class="p">:</span> <span class="nx">local</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">,</span>
      <span class="na">commit</span><span class="p">:</span> <span class="nx">local</span><span class="p">.</span><span class="nx">commit</span><span class="p">,</span>
      <span class="na">getters</span><span class="p">:</span> <span class="nx">local</span><span class="p">.</span><span class="nx">getters</span><span class="p">,</span>
      <span class="na">state</span><span class="p">:</span> <span class="nx">local</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span>
      <span class="na">rootGetters</span><span class="p">:</span> <span class="nx">store</span><span class="p">.</span><span class="nx">getters</span><span class="p">,</span>
      <span class="na">rootState</span><span class="p">:</span> <span class="nx">store</span><span class="p">.</span><span class="nx">state</span>
    <span class="p">},</span> <span class="nx">payload</span><span class="p">,</span> <span class="nx">cb</span><span class="p">)</span>
    <span class="cm">/* 判断是否是Promise */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isPromise</span><span class="p">(</span><span class="nx">res</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/* 不是Promise对象的时候转化称Promise对象 */</span>
      <span class="nx">res</span> <span class="o">=</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">store</span><span class="p">.</span><span class="nx">_devtoolHook</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* 存在devtool插件的时候触发vuex的error给devtool */</span>
      <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">store</span><span class="p">.</span><span class="nx">_devtoolHook</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'vuex:error'</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">throw</span> <span class="nx">err</span>
      <span class="p">})</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div> <p>因为registerAction的时候将push进_actions的action进行了一层封装（wrappedActionHandler），所以我们在进行dispatch的第一个参数中获取state、commit等方法。之后，执行结果res会被进行判断是否是Promise，不是则会进行一层封装，将其转化成Promise对象。dispatch时则从_actions中取出，只有一个的时候直接返回，否则用Promise.all处理再返回。</p> <h3 id="watch">watch</h3> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 观察一个getter方法 */</span>
<span class="nx">watch</span> <span class="p">(</span><span class="nx">getter</span><span class="p">,</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">getter</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">,</span> <span class="err">`</span><span class="nx">store</span><span class="p">.</span><span class="nx">watch</span> <span class="nx">only</span> <span class="nx">accepts</span> <span class="nx">a</span> <span class="kd">function</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_watcherVM</span><span class="p">.</span><span class="nx">$watch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">getter</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">getters</span><span class="p">),</span> <span class="nx">cb</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>熟悉Vue的朋友应该很熟悉watch这个方法。这里采用了比较巧妙的设计，_watcherVM是一个Vue的实例，所以watch就可以直接采用了Vue内部的watch特性提供了一种观察数据getter变动的方法。</p> <h3 id="registermodule">registerModule</h3> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 注册一个动态module，当业务进行异步加载的时候，可以通过该接口进行注册动态module */</span>
<span class="nx">registerModule</span> <span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">rawModule</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 转化称Array */</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">path</span> <span class="o">===</span> <span class="s1">'string'</span><span class="p">)</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[</span><span class="nx">path</span><span class="p">]</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span> <span class="err">`</span><span class="nx">module</span> <span class="nx">path</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">string</span> <span class="nx">or</span> <span class="nx">an</span> <span class="nb">Array</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'cannot register the root module by using registerModule.'</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="cm">/*注册*/</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">rawModule</span><span class="p">)</span>
  <span class="cm">/*初始化module*/</span>
  <span class="nx">installModule</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">path</span><span class="p">))</span>
  <span class="c1">// reset store to update getters...</span>
  <span class="cm">/* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */</span>
  <span class="nx">resetStoreVM</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>registerModule用以注册一个动态模块，也就是在store创建以后再注册模块的时候用该接口。内部实现实际上也只有installModule与resetStoreVM两个步骤，前面已经讲过，这里不再累述。</p> <h3 id="unregistermodule">unregisterModule</h3> <div class="highlighter-rouge"><pre class="highlight"><code> <span class="cm">/* 注销一个动态module */</span>
<span class="nx">unregisterModule</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 转化称Array */</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">path</span> <span class="o">===</span> <span class="s1">'string'</span><span class="p">)</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[</span><span class="nx">path</span><span class="p">]</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">assert</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">path</span><span class="p">),</span> <span class="err">`</span><span class="nx">module</span> <span class="nx">path</span> <span class="nx">must</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">string</span> <span class="nx">or</span> <span class="nx">an</span> <span class="nb">Array</span><span class="p">.</span><span class="err">`</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="cm">/*注销*/</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">unregister</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_withCommit</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="cm">/* 获取父级的state */</span>
    <span class="kr">const</span> <span class="nx">parentState</span> <span class="o">=</span> <span class="nx">getNestedState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="cm">/* 从父级中删除 */</span>
    <span class="nx">Vue</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">parentState</span><span class="p">,</span> <span class="nx">path</span><span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">})</span>
  <span class="cm">/* 重制store */</span>
  <span class="nx">resetStore</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>同样，与registerModule对应的方法unregisterModule，动态注销模块。实现方法是先从state中删除模块，然后用resetStore来重制store。</p> <h3 id="resetstore">resetStore</h3> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 重制store */</span>
<span class="kd">function</span> <span class="nx">resetStore</span> <span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">hot</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_actions</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_mutations</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_wrappedGetters</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_modulesNamespaceMap</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">state</span>
  <span class="c1">// init all modules</span>
  <span class="nx">installModule</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="p">[],</span> <span class="nx">store</span><span class="p">.</span><span class="nx">_modules</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="c1">// reset vm</span>
  <span class="nx">resetStoreVM</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">hot</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div> <p>这里的resetStore其实也就是将store中的_actions等进行初始化以后，重新执行installModule与resetStoreVM来初始化module以及用Vue特性使其“响应式化”，这跟构造函数中的是一致的。</p> <h2 id="section-2">插件</h2> <p>Vue提供了一个非常好用的插件<a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd">Vue.js devtools</a></p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* 从window对象的__VUE_DEVTOOLS_GLOBAL_HOOK__中获取devtool插件 */</span>
<span class="kr">const</span> <span class="nx">devtoolHook</span> <span class="o">=</span>
  <span class="k">typeof</span> <span class="nb">window</span> <span class="o">!==</span> <span class="s1">'undefined'</span> <span class="o">&amp;&amp;</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">__VUE_DEVTOOLS_GLOBAL_HOOK__</span>

<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">devtoolPlugin</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">devtoolHook</span><span class="p">)</span> <span class="k">return</span>

  <span class="cm">/* devtoll插件实例存储在store的_devtoolHook上 */</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">_devtoolHook</span> <span class="o">=</span> <span class="nx">devtoolHook</span>

  <span class="cm">/* 出发vuex的初始化事件，并将store的引用地址传给deltool插件，使插件获取store的实例 */</span>
  <span class="nx">devtoolHook</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'vuex:init'</span><span class="p">,</span> <span class="nx">store</span><span class="p">)</span>

  <span class="cm">/* 监听travel-to-state事件 */</span>
  <span class="nx">devtoolHook</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'vuex:travel-to-state'</span><span class="p">,</span> <span class="nx">targetState</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="cm">/* 重制state */</span>
    <span class="nx">store</span><span class="p">.</span><span class="nx">replaceState</span><span class="p">(</span><span class="nx">targetState</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="cm">/* 订阅store的变化 */</span>
  <span class="nx">store</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">((</span><span class="nx">mutation</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">devtoolHook</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'vuex:mutation'</span><span class="p">,</span> <span class="nx">mutation</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div> <p>如果已经安装了该插件，则会在windows对象上暴露一个__VUE_DEVTOOLS_GLOBAL_HOOK__。devtoolHook用在初始化的时候会触发“vuex:init”事件通知插件，然后通过on方法监听“vuex:travel-to-state”事件来重置state。最后通过Store的subscribe方法来添加一个订阅者，在触发commit方法修改mutation数据以后，该订阅者会被通知，从而触发“vuex:mutation”事件。</p> <h2 id="section-3">最后</h2> <p>Vuex是一个非常优秀的库，代码量不多且结构清晰，非常适合研究学习其内部实现。最近的一系列源码阅读也使我自己受益匪浅，写这篇文章也希望可以帮助到更多想要学习探索Vuex内部实现原理的同学。</p> </div> </article> <footer class="site-footer"> <div class="container"> <ul class="social"> <li><a href="http://github.com/answershuto" target="_blank"><i class="icon icon-github"></i></a></li> </ul> <p> <br><small>&copy;2018 CaoYang , All rights reserved.</small> </p> </div> </footer> </main> <script src="/assets/js/jquery-2.1.1.js"></script> <script src="/assets/js/main.js"></script> </body> </html><!-- by nandomoreira.me -->